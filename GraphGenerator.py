import random
from itertools import permutations

import networkx as nx
import scipy as sp


def validate_input(G, pos_name):
    # Input validation - every node must have a "pos" attribute
    for n, pos in G.nodes(data=pos_name):
        if pos is None:
            raise nx.NetworkXError(
                f"Node {n} (and all nodes) must have a '{pos_name}' attribute."
            )


def add_directed_rdg_edges(G, p=2, *, pos_name="pos"):
    """
    Returns directional edge list of node pairs, if v is within radius of u.

    Parameters
    ----------
    G : networkx graph
        The graph from which to generate the edge list. The nodes in `G` should
        have an attribute ``pos`` corresponding to the node position, which is
        used to compute the distance to other nodes.
    pos_name : string, default="pos"
        The name of the node attribute which represents the position of each
        node in 2D coordinates. Every node in the Graph must have this attribute.
    p : scalar, default=2
        The `Minkowski distance metric
        <https://en.wikipedia.org/wiki/Minkowski_distance>`_ used to compute
        distances. The default value is 2, i.e. Euclidean distance.

    Returns
    -------
    edges : list
        List of edges whose distances are less than radius.
    """
    nodes_data = G.nodes(data=True)

    # Parse node positions and radii
    node_list, data = list(zip(*nodes_data))
    radius_list = [sample["rad"] for sample in data]
    position_list = [sample["pos"] for sample in data]

    kdtree = sp.spatial.KDTree(position_list)

    for node in node_list:
        # Find nodes in transfer radius of node
        edge_indexes = kdtree.query_ball_point(
            position_list[node], radius_list[node], p
        )
        # Filter out node itself from edge_indexes
        edge_indexes.remove(node)
        G.add_edges_from([(node, neighbor) for neighbor in edge_indexes])


def generate_random_node_positions(
    number_of_nodes: int,
    position_lower_bound: float,
    position_upper_bound: float,
    dim: int,
) -> dict:
    random_node_positions = {
        v: [
            random.uniform(position_lower_bound, position_upper_bound)
            for i in range(dim)
        ]
        for v in range(number_of_nodes)
    }
    return random_node_positions


def directed_random_disk_graph(
    n,
    radius_lower_bound=0.1,
    radius_upper_bound=1,
    position_lower_bound=0,
    position_upper_bound=5,
    dim=2,
    pos=None,
    p=2,
    seed=None,
    *,
    pos_name="pos",
) -> nx.DiGraph:
    """
    Returns a directed random disk graph in the cube of dimensions 'dim'.

    The random geometric graph model places 'n' nodes uniformly at
    random in the unit cube. Two nodes are joined by an edge if the
    distance between the nodes is at most 'radius'.

    Parameters
    ----------
    n : int or iterable
        Number of nodes or iterable of nodes.
    radius_lower_bound : float, optional
        Lower bound of the transfer radius of each node.
    radius_upper_bound : float, optional
        Upper bound of the transfer radius of each node.
    position_lower_bound : float, optional
        Lower bound of the position of each node.
    position_upper_bound : float, optional
        Upper bound of the position of each node.
    dim : int, optional
        Dimension of graph.
    pos : dict, optional
        A dictionary keyed by node with node positions as values.
    p : float, optional
        Which Minkowski distance metric to use.  `p` has to meet the condition
        ``1 <= p <= infinity``.

        If this argument is not specified, the :math:`L^2` metric
        (the Euclidean distance metric), p = 2 is used.
        This should not be confused with the `p` of an Erdős-Rényi random
        graph, which represents probability.
    seed : integer, random_state, or None (default)
        Indicator of random number generation state.
    pos_name : string, default="pos"
        The name of the node attribute which represents the position
        in 2D coordinates of the node in the returned graph.

    Returns
    -------
    DiGraph
        A random disk graph, directed and without self-loops.
        Each node has a node attribute 'pos' that stores the
        position of that node in Euclidean space as provided by the
        'pos' keyword argument or, if 'pos' was not provided, as
        generated by this function.
    """

    G = nx.empty_graph(n, create_using=nx.DiGraph)

    # Set a random transfer radius for each node
    radii = {v: random.uniform(radius_lower_bound, radius_upper_bound) for v in G}
    nx.set_node_attributes(G, radii, name="rad")

    # If no positions are provided, choose uniformly random vectors in Euclidean space of the specified dimension.
    random.seed(seed)
    if pos is None:
        pos = {
            v: [
                random.uniform(position_lower_bound, position_upper_bound)
                for i in range(dim)
            ]
            for v in G
        }
    nx.set_node_attributes(G, pos, pos_name)
    add_directed_rdg_edges(G, p, pos_name=pos_name)
    return G


def delaunay_triangulation_edges(node_positions: list) -> list:
    """
    Returns directional edge list of the Delaunay triangulation of the nodes in `rdg`.

    Parameters
    ----------
    rdg : nx.DiGraph
        Random disk graph generated from directed_random_disk_graph().

    Returns
    -------
    edge_list : list
        List of edges computed from the Delaunay triangulation of the nodes in `rdg`.
    """

    # nodes_data = rdg.nodes(data=True)
    # nodes, data = list(zip(*nodes_data))
    # Convert node positions from dict to list
    coordinates = [node_positions[n] for n in node_positions]
    tri = sp.spatial.Delaunay(points=coordinates)
    # Create edge list from the simplices
    edge_list = []
    for simplex in tri.simplices:
        for edge in permutations(simplex, 2):
            edge_list.append(edge)
    return edge_list


def random_planar_graph(
    n,
    radius_lower_bound=0.1,
    radius_upper_bound=1,
    position_lower_bound=0,
    position_upper_bound=5,
    dim=2,
    p=2,
    seed=None,
    *,
    pos_name="pos",
) -> nx.DiGraph:
    """
    Returns a random planar graph by computing the Delaunay triangulation from a directed random disk graph.

    Parameters
    ----------
    See directed_random_disk_graph().

    Returns
    -------
    directed_planar_rdg : nx.DiGraph
        A random planar graph, based on a random disk graph and made planar by computing the Delaunay triangulation.
    """
    random_node_positions = generate_random_node_positions(
        n, position_lower_bound, position_upper_bound, dim
    )
    # Generate a directed rdg
    directed_rdg = directed_random_disk_graph(
        n,
        radius_lower_bound,
        radius_upper_bound,
        position_lower_bound,
        position_upper_bound,
        dim,
        random_node_positions,
        p,
        seed,
        pos_name=pos_name,
    )
    # Compute the Delaunay triangulation of the nodes
    delaunay_edges = delaunay_triangulation_edges(random_node_positions)
    invalid_edges = list(set(directed_rdg.edges).difference(delaunay_edges))
    directed_rdg.remove_edges_from(invalid_edges)
    # Return the resulting graph
    return directed_rdg
